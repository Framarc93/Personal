'''MGGPTreeTuner_G2C4NNTrain: script to tune a MGGP Tree to face different conditions

This script takes a MGGP function generated by the script "G2C_MGGPLawMultiGenerator.py" and test it on different
Cd and time_change conditions for n_samples, optimizing the law parameter every time to find the best ones that produces
a successfull controller for the selected case. The data at the end are store in the dataset matrix "dataset_forNN_{}samples.npy".
The dataset has the following shape:
dataset = [r.T, theta.T, vr.T, vt.T, er.T, et.T, evr.T, evt.T, param1, param2, ..., paramn]

Author(s): Francesco Marchetti
email: francesco.marchetti@strath.ac.uk

References:
relevant references for the algorithm'''

import random
from deap import gp, base
from deap import creator
import _pickle as cPickle
from hyperopt import Trials, fmin, hp, tpe
from scipy.interpolate import PchipInterpolator
import numpy as np
from scipy.integrate import solve_ivp
from functools import partial
import operator
import sys
from copy import deepcopy
from scipy.optimize import minimize

laptop = True
if laptop:
    initial_path = "/home/francesco/Desktop/PhD/Git_workspace/IC4A2S"
else:
    initial_path = "/home/francesco/Desktop/Git_workspace/IC4A2S"

sys.path.insert(1, initial_path + "/Goddard_Problem/Testing/Goddard_1Control")
import GP_PrimitiveSet as gpprim

class FitnessMulti(object):
    '''Fitness class modified from DEAP library. Only modification is the sum inserted in the comparison functions'''

    weights = None
    """The weights are used in the fitness comparison. They are shared among
    all fitnesses of the same type. When subclassing :class:`Fitness`, the
    weights must be defined as a tuple where each element is associated to an
    objective. A negative weight element corresponds to the minimization of
    the associated objective and positive weight to the maximization.

    .. note::
        If weights is not defined during subclassing, the following error will
        occur at instantiation of a subclass fitness object:

        ``TypeError: Can't instantiate abstract <class Fitness[...]> with
        abstract attribute weights.``
    """

    wvalues = ()
    """Contains the weighted values of the fitness, the multiplication with the
    weights is made when the values are set via the property :attr:`values`.
    Multiplication is made on setting of the values for efficiency.

    Generally it is unnecessary to manipulate wvalues as it is an internal
    attribute of the fitness used in the comparison operators.
    """

    def __init__(self, values=()):
        if self.weights is None:
            raise TypeError("Can't instantiate abstract %r with abstract "
                            "attribute weights." % (self.__class__))

        if not isinstance(self.weights, Sequence):
            raise TypeError("Attribute weights of %r must be a sequence."
                            % self.__class__)

        if len(values) > 0:
            self.values = values

    def getValues(self):
        return tuple(map(truediv, self.wvalues, self.weights))

    def setValues(self, values):
        try:
            self.wvalues = tuple(map(mul, values, self.weights))
        except TypeError:
            _, _, traceback = sys.exc_info()
            raise TypeError("Both weights and assigned values must be a "
                            "sequence of numbers when assigning to values of "
                            "%r. Currently assigning value(s) %r of %r to a "
                            "fitness with weights %s."
                            % (self.__class__, values, type(values),
                               self.weights)).with_traceback(traceback)

    def delValues(self):
        self.wvalues = ()

    values = property(getValues, setValues, delValues,
                      ("Fitness values. Use directly ``individual.fitness.values = values`` "
                       "in order to set the fitness and ``del individual.fitness.values`` "
                       "in order to clear (invalidate) the fitness. The (unweighted) fitness "
                       "can be directly accessed via ``individual.fitness.values``."))

    def dominates(self, other, obj=slice(None)):
        """Return true if each objective of *self* is not strictly worse than
        the corresponding objective of *other* and at least one objective is
        strictly better.

        :param obj: Slice indicating on which objectives the domination is
                    tested. The default value is `slice(None)`, representing
                    every objectives.
        """
        not_equal = False
        for self_wvalue, other_wvalue in zip(self.wvalues[obj], other.wvalues[obj]):
            if self_wvalue > other_wvalue:
                not_equal = True
            elif self_wvalue < other_wvalue:
                return False
        return not_equal

    @property
    def valid(self):
        """Assess if a fitness is valid or not."""
        return len(self.wvalues) != 0

    def __hash__(self):
        return hash(self.wvalues)

    def __gt__(self, other):
        return not self.__le__(other)

    def __ge__(self, other):
        return not self.__lt__(other)

    def __le__(self, other):
        return sum(self.wvalues) <= sum(other.wvalues)

    def __lt__(self, other):
        return sum(self.wvalues) < sum(other.wvalues)

    def __eq__(self, other):
        return sum(self.wvalues == other.wvalues)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __deepcopy__(self, memo):
        """Replace the basic deepcopy function with a faster one.

        It assumes that the elements in the :attr:`values` tuple are
        immutable and the fitness does not contain any other object
        than :attr:`values` and :attr:`weights`.
        """
        copy_ = self.__class__()
        copy_.wvalues = self.wvalues
        return copy_

    def __str__(self):
        """Return the values of the Fitness object."""
        return str(self.values if self.valid else tuple())

    def __repr__(self):
        """Return the Python code to build a copy of the object."""
        return "%s.%s(%r)" % (self.__module__, self.__class__.__name__,
                              self.values if self.valid else tuple())

class HallOfFame(object):
    """The hall of fame contains the best individual that ever lived in the
    population during the evolution. It is lexicographically sorted at all
    time so that the first element of the hall of fame is the individual that
    has the best first fitness value ever seen, according to the weights
    provided to the fitness at creation time.

    The insertion is made so that old individuals have priority on new
    individuals. A single copy of each individual is kept at all time, the
    equivalence between two individuals is made by the operator passed to the
    *similar* argument.

    :param maxsize: The maximum number of individual to keep in the hall of
                    fame.
    :param similar: An equivalence operator between two individuals, optional.
                    It defaults to operator :func:`operator.eq`.

    The class :class:`HallOfFame` provides an interface similar to a list
    (without being one completely). It is possible to retrieve its length, to
    iterate on it forward and backward and to get an item or a slice from it.
    """

    def __init__(self, maxsize, similar=operator.eq):
        self.maxsize = maxsize
        self.keys = list()
        self.items = list()
        self.similar = similar

    def shuffle(self):
        arr_start = deepcopy(self.items)
        while len(arr_start) > 0:
            arr_end = []
            ind = random.randint(0, len(arr_start) - 1)
            arr_end.append(arr_start[ind])
            arr_start.pop(ind)
        return arr_end

    def update(self, population, for_feasible):
        """Update the hall of fame with the *population* by replacing the
        worst individuals in it by the best individuals present in
        *population* (if they are better). The size of the hall of fame is
        kept constant.

        :param population: A list of individual with a fitness attribute to
                           update the hall of fame with.
        """
        if len(self) == 0 and self.maxsize != 0 and len(population) > 0:
            # Working on an empty hall of fame is problematic for the
            # "for else"
            self.insert(population[0], for_feasible)

        if for_feasible is True:
            for ind in population:
                if ind.fitness.values[-1] == 0.0:  ### NEW PART - REMOVE IF DOESNT WORK ####
                    if self[0].fitness.values[-1] == 0.0:
                        if sum(ind.fitness.values) < sum(self[0].fitness.values) or len(self) < self.maxsize:
                            for hofer in self:
                                # Loop through the hall of fame to check for any
                                # similar individual
                                if self.similar(ind, hofer):
                                    break
                            else:
                                # The individual is unique and strictly better than
                                # the worst
                                if len(self) >= self.maxsize:
                                    self.remove(0)
                                self.insert(ind, for_feasible)
                    else:
                        for hofer in self:
                            # Loop through the hall of fame to check for any
                            # similar individual
                            if self.similar(ind, hofer):
                                break
                        else:
                            # The individual is unique and strictly better than
                            # the worst
                            if len(self) >= self.maxsize:
                                self.remove(0)
                            self.insert(ind, for_feasible)  #### END NEW PART ######
                elif (sum(ind.fitness.values) < sum(self[0].fitness.values)) or len(self) < self.maxsize:
                    for hofer in self:
                        # Loop through the hall of fame to check for any
                        # similar individual
                        if self.similar(ind, hofer):
                            break
                    else:
                        # The individual is unique and strictly better than
                        # the worst
                        if len(self) >= self.maxsize:
                            self.remove(0)
                        self.insert(ind, for_feasible)
        else:
            for ind in population:
                if ind.fitness.values[0] < 10 and ind.fitness.values[1] < 40 and sum(ind.fitness.values) < sum(
                        self[0].fitness.values) or len(self) < self.maxsize:
                    for hofer in self:
                        # Loop through the hall of fame to check for any
                        # similar individual
                        if self.similar(ind, hofer):
                            break
                    else:
                        # The individual is unique and strictly better than
                        # the worst
                        if len(self) >= self.maxsize:
                            self.remove(0)
                        self.insert(ind, for_feasible)

    def insert(self, item, for_feasible):
        """Insert a new individual in the hall of fame using the
        :func:`~bisect.bisect_right` function. The inserted individual is
        inserted on the right side of an equal individual. Inserting a new
        individual in the hall of fame also preserve the hall of fame's order.
        This method **does not** check for the size of the hall of fame, in a
        way that inserting a new individual in a full hall of fame will not
        remove the worst individual to maintain a constant size.

        :param item: The individual with a fitness attribute to insert in the
                     hall of fame.
        """

        def bisect_right(a, x, lo=0, hi=None):
            """Return the index where to insert item x in list a, assuming a is sorted.
            The return value i is such that all e in a[:i] have e <= x, and all e in
            a[i:] have e > x.  So if x already appears in the list, a.insert(x) will
            insert just after the rightmost x already there.
            Optional args lo (default 0) and hi (default len(a)) bound the
            slice of a to be searched.
            """

            if lo < 0:
                raise ValueError('lo must be non-negative')
            if hi is None:
                hi = len(a)
            while lo < hi:
                mid = (lo + hi) // 2
                '''must indentify 4 cases: if both are feasible, if the new is feasible and the one in the list is not, viceversa and if both are infeasible'''
                if for_feasible is True:
                    # 1st case: both are feasible
                    if x.values[-1] == 0 and a[mid].values[-1] == 0:
                        if sum(x.values) < sum(a[mid].values):
                            hi = mid
                        else:
                            lo = mid + 1
                    # 2nd case: value to insert is feasible, the one in the list is not
                    elif x.values[-1] == 0 and a[mid].values[-1] != 0:
                        hi = mid
                    # 3rd case: value to insert is not feasible, the one in the list is feasible
                    elif x.values[-1] != 0 and a[mid].values[-1] == 0:
                        lo = mid + 1
                    # 4th case: both are infeasible
                    elif x.values[-1] != 0 and a[mid].values[-1] != 0:
                        if x.values[-1] < a[mid].values[-1]:
                            hi = mid
                        else:
                            lo = mid + 1
                else:
                    if sum(x.values) < sum(a[mid].values):
                        hi = mid
                    else:
                        lo = mid + 1
            return lo

        item = deepcopy(item)
        i = bisect_right(self.keys, item.fitness)
        self.items.insert(len(self) - i, item)
        self.keys.insert(i, item.fitness)

    def remove(self, index):
        """Remove the specified *index* from the hall of fame.

        :param index: An integer giving which item to remove.
        """
        del self.keys[len(self) - (index % len(self) + 1)]
        del self.items[index]

    def clear(self):
        """Clear the hall of fame."""
        del self.items[:]
        del self.keys[:]

    def __len__(self):
        return len(self.items)

    def __getitem__(self, i):
        return self.items[i]

    def __iter__(self):
        return iter(self.items)

    def __reversed__(self):
        return reversed(self.items)

    def __str__(self):
        return str(self.items)

Ngenes = 2
d = np.ones((Ngenes+1))*1.0  # weights for linear combination of genes
d[0] = 0
creator.create("Fitness", base.Fitness, weights=(-1.0, -1.0))
creator.create("Individual", list, fitness=creator.Fitness)
creator.create("SubIndividual", list, w=list(d), height=1)
creator.create("Trees", gp.PrimitiveTree)

toolbox = base.Toolbox()

'''definition of GP parameters used'''

nEph = 6
nCont = 3
psetR = gp.PrimitiveSet("Radial", 2)
psetR.addPrimitive(operator.add, 2, name="Add")
psetR.addPrimitive(operator.sub, 2, name="Sub")
psetR.addPrimitive(operator.mul, 2, name='Mul')
psetR.addPrimitive(gpprim.TriAdd, 3)
psetR.addPrimitive(np.tanh, 1, name="Tanh")
psetR.addPrimitive(gpprim.Sqrt, 1)
psetR.addPrimitive(gpprim.Log, 1)
psetR.addPrimitive(gpprim.modExp, 1)
psetR.addPrimitive(gpprim.Sin, 1)
psetR.addPrimitive(gpprim.Cos, 1)

for i in range(nEph):
    psetR.addEphemeralConstant("randR{}".format(i), lambda: round(random.uniform(-10, 10), 6))

psetR.renameArguments(ARG0='errR')
psetR.renameArguments(ARG1='errVr')

psetT = gp.PrimitiveSet("Tangential", 2)
psetT.addPrimitive(operator.add, 2, name="Add")
psetT.addPrimitive(operator.sub, 2, name="Sub")
psetT.addPrimitive(operator.mul, 2, name='Mul')
psetT.addPrimitive(gpprim.TriAdd, 3)
psetT.addPrimitive(np.tanh, 1, name="Tanh")
psetT.addPrimitive(gpprim.Sqrt, 1)
psetT.addPrimitive(gpprim.Log, 1)
psetT.addPrimitive(gpprim.modExp, 1)
psetT.addPrimitive(gpprim.Sin, 1)
psetT.addPrimitive(gpprim.Cos, 1)

for i in range(nEph):
    psetT.addEphemeralConstant("randT{}".format(i), lambda: round(random.uniform(-10, 10), 6))

psetT.renameArguments(ARG0='errTheta')
psetT.renameArguments(ARG1='errVt')

w1 = {"name": "w1", "value": 1}
w2 = {"name": "w2", "value": 1}
w3 = {"name": "w3", "value": 1}
w4 = {"name": "w4", "value": 1}

arguments = {"errR": w1,
             "errTheta": w2,
             "errVr": w3,
             "errVt": w4}


'''Retrieve the GP tree through pickle'''
objects = []
with (open(initial_path + "/Goddard_Problem/Testing/NN_Control_MGGP/hof_G2C_forNN_MGGP.pkl", "rb")) as openfile:
    while True:
        try:
            objects.append(cPickle.load(openfile))
        except EOFError:
            break

best_ind_hof = objects[0][0]

def eq_toCompile(individual):
    ws = 1
    eqR = str(individual[0].w[0]) + "+"
    while ws < len(individual[0].w):
        eqR = eqR + str(individual[0].w[ws]) + "*" + str(individual[0][ws - 1]) + "+"
        ws += 1
    eqR = list(eqR)
    del eqR[-1]
    eqR = "".join(eqR)

    ws = 1
    eqT = str(individual[1].w[0]) + "+"
    ws += 1
    while ws < len(individual[1].w):
        eqT = eqT + str(individual[1].w[ws]) + "*" + str(individual[1][ws - 1]) + "+"
        ws += 1
    eqT = list(eqT)
    del eqT[-1]
    eqT = "".join(eqT)

    return eqR, eqT

eqR, eqT = eq_toCompile(best_ind_hof)

fTr = gp.compile(eqR, pset=psetR) # control law compiled from Gp tree
fTt = gp.compile(eqT, pset=psetT) # control law compiled from Gp tree


values = []

values.append(arguments['errR']['value'])
values.append(arguments['errVr']['value'])
values.append(arguments['errTheta']['value'])
values.append(arguments['errVt']['value'])

values.extend(best_ind_hof[0].w)
values.extend(best_ind_hof[1].w)

for i in range(len(best_ind_hof)):
    for j in range(len(best_ind_hof[i])):
        for k in range(len(best_ind_hof[i][j])):
            if type(best_ind_hof[i][j][k]) == gp.randR0 or type(best_ind_hof[i][j][k]) == gp.randR1:
                values.append(best_ind_hof[i][j][k].value)

print(values)

### step 3 : storing the results of every iteration

Rref = np.load(initial_path + "/Goddard_Problem/2Controls/R.npy")
Thetaref = np.load(initial_path + "/Goddard_Problem/2Controls/Theta.npy")
Vrref = np.load(initial_path + "/Goddard_Problem/2Controls/Vr.npy")
Vtref = np.load(initial_path + "/Goddard_Problem/2Controls/Vt.npy")
mref = np.load(initial_path + "/Goddard_Problem/2Controls/m.npy")
Ttref = np.load(initial_path + "/Goddard_Problem/2Controls/Tt.npy")
Trref = np.load(initial_path + "/Goddard_Problem/2Controls/Tr.npy")
tref = np.load(initial_path + "/Goddard_Problem/2Controls/time.npy")
tfin = tref[-1]

Rfun = PchipInterpolator(tref, Rref)
Thetafun = PchipInterpolator(tref, Thetaref)
Vrfun = PchipInterpolator(tref, Vrref)
Vtfun = PchipInterpolator(tref, Vtref)
mfun = PchipInterpolator(tref, mref)
Trfun = PchipInterpolator(tref, Trref)
Ttfun = PchipInterpolator(tref, Ttref)

del Vrref, Vtref, mref, tref, Trref, Ttref

class Rocket:

    def __init__(self):
        self.GMe = 3.986004418 * 10 ** 14  # Earth gravitational constant [m^3/s^2]
        self.Re = 6371.0 * 1000  # Earth Radius [m]
        self.Vr = np.sqrt(self.GMe / self.Re)  # m/s
        self.H0 = 10.0  # m
        self.V0 = 0.0
        self.M0 = 100000.0  # kg
        self.Mp = self.M0 * 0.99
        self.Cd = 0.6
        self.A = 4.0  # m2
        self.Isp = 300.0  # s
        self.g0 = 9.80665  # m/s2
        self.Tmax = self.M0 * self.g0 * 1.5
        self.MaxQ = 14000.0  # Pa
        self.MaxG = 8.0  # G
        self.Htarget = 400.0 * 1000  # m
        self.Rtarget = self.Re + self.Htarget  # m/s
        self.a = [-0.0065, 0, 0.0010, 0.0028, 0, -0.0020, -0.0040, 0]
        self.a90 = [0.0030, 0.0050, 0.0100, 0.0200, 0.0150, 0.0100, 0.0070]
        self.hv = [11000, 20000, 32000, 47000, 52000, 61000, 79000, 90000]
        self.h90 = [90000, 100000, 110000, 120000, 150000, 160000, 170000, 190000]
        self.tmcoeff = [180.65, 210.65, 260.65, 360.65, 960.65, 1110.65, 1210.65]
        self.pcoeff = [0.16439, 0.030072, 0.0073526, 0.0025207, 0.505861E-3, 0.36918E-3, 0.27906E-3]
        self.tcoeff2 = [2.937, 4.698, 9.249, 18.11, 12.941, 8.12, 5.1]
        self.tcoeff1 = [180.65, 210.02, 257.0, 349.49, 892.79, 1022.2, 1103.4]
        self.Vtarget = np.sqrt(self.GMe / self.Rtarget)  # m/s

    @staticmethod
    def air_density(h):
        global flag
        beta = 1 / 8500.0  # scale factor [1/m]
        rho0 = 1.225  # kg/m3
        try:
            return rho0 * np.exp(-beta * h)
        except RuntimeWarning:
            flag = True
            return rho0 * np.exp(-beta * obj.Rtarget)

obj = Rocket()

def test_param_opt(param, Cd_test, t_ch):
    best_ind_hof[0].w = deepcopy([param[4], param[5]])
    best_ind_hof[1].w = deepcopy([param[6], param[7]])
    c = 8
    for i in range(len(best_ind_hof)):
        for j in range(len(best_ind_hof[i])):
            for k in range(len(best_ind_hof[i][j])):
                try:
                    if type(best_ind_hof[i][j][k]) == gp.randR0 or type(best_ind_hof[i][j][k]) == gp.randR1:
                        best_ind_hof[i][j][k] = deepcopy(best_ind_hof[i][j][k])
                        best_ind_hof[i][j][k].value = deepcopy(param[c])
                        c += 1
                except AttributeError:
                    continue
    eqR, eqT = eq_toCompile(best_ind_hof)
    fTr = gp.compile(eqR, pset=psetR)
    fTt = gp.compile(eqT, pset=psetT)

    penalty = []
    flag = False
    def sys2GP(t, x):
        global flag
        R = x[0]
        theta = x[1]
        Vr = x[2]
        Vt = x[3]
        m = x[4]

        if R < obj.Re - 0.5 or np.isnan(R):
            penalty.append((R - obj.Re) / obj.Htarget)
            R = obj.Re
            flag = True

        if m < obj.M0 - obj.Mp or np.isnan(m):
            penalty.append((m - (obj.M0 - obj.Mp)) / obj.M0)
            m = obj.M0 - obj.Mp
            flag = True

        r = Rfun(t)
        th = Thetafun(t)
        vr = Vrfun(t)
        vt = Vtfun(t)

        er = (r - R)*param[0]
        et = (th - theta)*param[1]
        evr = (vr - Vr)*param[2]
        evt = (vt - Vt)*param[3]

        if t >= t_ch:
            Cd = Cd_test
            Tr = Trfun(t) + fTr(er, evr)
            Tt = Ttfun(t) + fTt(et, evt)
        else:
            Cd = obj.Cd
            Tr = Trfun(t)
            Tt = Ttfun(t)

        rho = obj.air_density(R - obj.Re)
        Dr = 0.5 * rho * Vr * np.sqrt(Vr ** 2 + Vt ** 2) * Cd * obj.A  # [N]
        Dt = 0.5 * rho * Vt * np.sqrt(Vr ** 2 + Vt ** 2) * Cd * obj.A  # [N]
        g = obj.g0 * (obj.Re / R) ** 2  # [m/s2]
        g0 = obj.g0
        Isp = obj.Isp

        if np.iscomplex(Tr):
            flag = True
            Tr = 0
        elif Tr < 0.0 or np.isnan(Tr):
            penalty.append((Tr) / obj.Tmax)
            Tr = 0.0
            flag = True
        elif Tr > obj.Tmax or np.isinf(Tr):
            penalty.append((Tr - obj.Tmax) / obj.Tmax)
            Tr = obj.Tmax
            flag = True
        if np.iscomplex(Tt):
            flag = True
            Tt = 0
        elif Tt < 0.0 or np.isnan(Tt):
            penalty.append((Tt) / obj.Tmax)
            Tt = 0.0
            flag = True
        elif Tt > obj.Tmax or np.isinf(Tt):
            penalty.append((Tt - obj.Tmax) / obj.Tmax)
            Tt = obj.Tmax
            flag = True

        dxdt = np.array((Vr,
                         Vt / R,
                         Tr / m - Dr / m - g + Vt ** 2 / R,
                         Tt / m - Dt / m - (Vr * Vt) / R,
                         -np.sqrt(Tt ** 2 + Tr ** 2) / g0 / Isp))
        return dxdt


    x_start = [obj.Re, 0.0, 0.0, 0.0, obj.M0]
    #tev = np.linspace(0.0, tfin, 500)
    solgp = solve_ivp(sys2GP, [0, tfin], x_start)
    y1 = solgp.y[0, :]
    y2 = solgp.y[1, :]
    if solgp.t[-1] < tfin:
        penalty.append((solgp.t[-1] - tfin)/tfin)
        flag = True

    if flag is True:
        return False, solgp
    if (Rref[-1]-obj.Re) * 0.99 < (y1[-1]-obj.Re) < (Rref[-1]-obj.Re) * 1.01 and Thetaref[-1] * 0.99 < y2[-1] < Thetaref[-1] * 1.01:  # tolerance of 1%
        return True, solgp
    else:
        return False, solgp

def tree_eval_opt(param, Cd_test, t_ch):
    best_ind_hof[0].w = deepcopy([param[4], param[5]])
    best_ind_hof[1].w = deepcopy([param[6], param[7]])
    c = 8
    for i in range(len(best_ind_hof)):
        for j in range(len(best_ind_hof[i])):
            for k in range(len(best_ind_hof[i][j])):
                try:
                    if type(best_ind_hof[i][j][k]) == gp.randR0 or type(best_ind_hof[i][j][k]) == gp.randR1:
                        best_ind_hof[i][j][k] = deepcopy(best_ind_hof[i][j][k])
                        best_ind_hof[i][j][k].value = deepcopy(param[c])
                        c += 1
                except AttributeError:
                    continue
    eqR, eqT = eq_toCompile(best_ind_hof)
    fTr = gp.compile(eqR, pset=psetR)
    fTt = gp.compile(eqT, pset=psetT)

    penalty = []
    flag = False

    def sys2GP(t, x):
        global flag
        R = x[0]
        theta = x[1]
        Vr = x[2]
        Vt = x[3]
        m = x[4]

        if R < obj.Re - 0.5 or np.isnan(R):
            penalty.append((R - obj.Re) / obj.Htarget)
            R = obj.Re
            flag = True

        if m < obj.M0 - obj.Mp or np.isnan(m):
            penalty.append((m - (obj.M0 - obj.Mp)) / obj.M0)
            m = obj.M0 - obj.Mp
            flag = True

        r = Rfun(t)
        th = Thetafun(t)
        vr = Vrfun(t)
        vt = Vtfun(t)

        er = (r - R)*param[0]
        et = (th - theta)*param[1]
        evr = (vr - Vr)*param[2]
        evt = (vt - Vt)*param[3]

        if t >= t_ch:
            Cd = Cd_test
            Tr = Trfun(t) + fTr(er, evr)
            Tt = Ttfun(t) + fTt(et, evt)
        else:
            Cd = obj.Cd
            Tr = Trfun(t)
            Tt = Ttfun(t)

        rho = obj.air_density(R - obj.Re)
        Dr = 0.5 * rho * Vr * np.sqrt(Vr ** 2 + Vt ** 2) * Cd * obj.A  # [N]
        Dt = 0.5 * rho * Vt * np.sqrt(Vr ** 2 + Vt ** 2) * Cd * obj.A  # [N]
        g = obj.g0 * (obj.Re / R) ** 2  # [m/s2]
        g0 = obj.g0
        Isp = obj.Isp

        if np.iscomplex(Tr):
            flag = True
            Tr = 0
        elif Tr < 0.0 or np.isnan(Tr):
            penalty.append((Tr) / obj.Tmax)
            Tr = 0.0
            flag = True
        elif Tr > obj.Tmax or np.isinf(Tr):
            penalty.append((Tr - obj.Tmax) / obj.Tmax)
            Tr = obj.Tmax
            flag = True
        if np.iscomplex(Tt):
            flag = True
            Tt = 0
        elif Tt < 0.0 or np.isnan(Tt):
            penalty.append((Tt) / obj.Tmax)
            Tt = 0.0
            flag = True
        elif Tt > obj.Tmax or np.isinf(Tt):
            penalty.append((Tt - obj.Tmax) / obj.Tmax)
            Tt = obj.Tmax
            flag = True

        dxdt = np.array((Vr,
                         Vt / R,
                         Tr / m - Dr / m - g + Vt ** 2 / R,
                         Tt / m - Dt / m - (Vr * Vt) / R,
                         -np.sqrt(Tt ** 2 + Tr ** 2) / g0 / Isp))
        return dxdt

    x_start = [obj.Re, 0.0, 0.0, 0.0, obj.M0]
    solgp = solve_ivp(sys2GP, [0.0, tfin], x_start,method='RK23')
    y1 = solgp.y[0, :]
    y2 = solgp.y[1, :]
    if solgp.t[-1] < tfin:
        penalty.append((solgp.t[-1] - tfin)/tfin)
        flag = True
    r = Rfun(solgp.t)
    theta = Thetafun(solgp.t)
    err1 = (r - y1) / obj.Htarget
    err2 = (theta - y2) / 0.9
    f1 = np.sqrt(sum(err1**2))
    f2 = np.sqrt(sum(err2**2))
    use = f1 + f2
    if flag is True:
        loss = use + np.sqrt(sum(np.array(penalty)**2))
        return loss
    else:
        return use

def sys2GP_eval(t, x):
    R = x[0]
    theta = x[1]
    Vr = x[2]
    Vt = x[3]
    m = x[4]

    r = Rfun(t)
    th = Thetafun(t)
    vr = Vrfun(t)
    vt = Vtfun(t)

    er = (r - R)
    et = (th - theta)
    evr = (vr - Vr)
    evt = (vt - Vt)

    Cd = obj.Cd
    Tr = Trfun(t) + fTr(er, evr)
    Tt = Ttfun(t) + fTt(et, evt)

    rho = obj.air_density(R - obj.Re)
    Dr = 0.5 * rho * Vr * np.sqrt(Vr ** 2 + Vt ** 2) * Cd * obj.A  # [N]
    Dt = 0.5 * rho * Vt * np.sqrt(Vr ** 2 + Vt ** 2) * Cd * obj.A  # [N]
    g = obj.g0 * (obj.Re / R) ** 2  # [m/s2]
    g0 = obj.g0
    Isp = obj.Isp

    if np.iscomplex(Tr):
        Tr = 0
    elif Tr < 0.0 or np.isnan(Tr):
        Tr = 0.0
    elif Tr > obj.Tmax or np.isinf(Tr):
        Tr = obj.Tmax
    if np.iscomplex(Tt):
        Tt = 0
    elif Tt < 0.0 or np.isnan(Tt):
        Tt = 0.0
    elif Tt > obj.Tmax or np.isinf(Tt):
        Tt = obj.Tmax


    dxdt = np.array((Vr,
                     Vt / R,
                     Tr / m - Dr / m - g + Vt ** 2 / R,
                     Tt / m - Dt / m - (Vr * Vt) / R,
                     -np.sqrt(Tt ** 2 + Tr ** 2) / g0 / Isp))
    return dxdt

tt = np.linspace(0.0, tfin, 100)
x_start = [obj.Re, 0.0, 0.0, 0.0, obj.M0]
solgp = solve_ivp(sys2GP_eval, [0.0, tfin], x_start)

dataset = np.column_stack((solgp.y[0,:].reshape(len(solgp.t),1), solgp.y[1,:].reshape(len(solgp.t),1), solgp.y[2,:].reshape(len(solgp.t),1),
           solgp.y[2,:].reshape(len(solgp.t),1), (Rfun(solgp.t)-solgp.y[0,:]).reshape(len(solgp.t),1), (Thetafun(solgp.t)-solgp.y[1,:]).reshape(len(solgp.t),1),
           (Vrfun(solgp.t)-solgp.y[2,:]).reshape(len(solgp.t),1), (Vtfun(solgp.t)-solgp.y[3,:]).reshape(len(solgp.t),1)))
for vv in values:
    dataset = np.column_stack((dataset, np.ones((len(solgp.t), 1)) * vv))

train_samples = np.load('/home/francesco/Desktop/PhD/Git_workspace/IC4A2S/Goddard_Problem/Testing/testdata_cd.npy')
n_samples = len(train_samples)

try_again=False
n = 0
while n < n_samples:
    '''t_change = random.uniform(20, 200)
    if t_change < 100:
        Cd_test = random.uniform(0.61, 1)
    else:
        Cd_test = random.uniform(0.61, 2)'''
    t_change = train_samples[n][1]
    Cd_test = train_samples[n][0]

    space = {}
    Cd_orig = 0.6
    best = minimize(tree_eval_opt, values, args=(Cd_test, t_change), method='BFGS')
    success, res = test_param_opt(best.x, Cd_test, t_change)
    if success is True:
        print("{} - Cd = {}, t change = {}".format(n, round(Cd_test, 2), round(t_change, 2)))
        best_val = list(best.x)
        data = np.column_stack((res.y[0,:].reshape(len(res.t),1), res.y[1,:].reshape(len(res.t),1), res.y[2,:].reshape(len(res.t),1),
                res.y[3,:].reshape(len(res.t),1), (Rfun(res.t)-res.y[0,:]).reshape(len(res.t),1), (Thetafun(res.t)-res.y[1,:]).reshape(len(res.t),1),
                (Vrfun(res.t)-res.y[2,:]).reshape(len(res.t),1), (Vtfun(res.t)-res.y[3,:]).reshape(len(res.t),1)))
        for vv in best_val:
            data = np.column_stack((data, np.ones((len(res.t), 1)) * vv))

        dataset = np.vstack((dataset, data))
    else:
        print("FAIL - Cd = {}, t change = {}".format(round(Cd_test, 2), round(t_change, 2)))
    n += 1

np.save(initial_path + "/Goddard_Problem/Testing/NN_Control_MGGP/dataset_forNN_MGGP_{}samples.npy".format(n_samples), dataset)

